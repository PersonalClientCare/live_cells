---
title: User Defined Types
description: Describes how to extend Live Cells for user defined types
---

# User Defined Types

So far we've used cells holding strings and numbers, and an
`enum`. What about types defined by your own classes?

A cell can generally hold a value of any type, as long as `==` is
suitably defined.

## Live Cell Extension

The
[`live_cell_extension`](https://pub.dev/packages/live_cell_extension)
package provides a source code generator that allows you to extend the
core cell interfaces, `ValueCell` and `MutableCell`, with accessors
for properties of your own classes.

To understand what this means, consider the following class:

<CodeGroup title="Person class">
```dart
class Person {
	final String firstName;
	final String lastName;
	final int age;
	
	const Person({
		required this.firstName,
		required this.lastName,
		required this.age
	});
}
```
</CodeGroup>

Let's say you have a cell holding a `Person`:

<CodeGroup title="Person cell">
```dart
final person = MutableCell(
	Person(
		firstName: 'John',
		lastName: 'Smith',
		age: 25
	)
);
```
</CodeGroup>

To access a property of the `Person` held in the cell, you will need
to defined a computed cell:

<CodeGroup title="Accessing properties in cells">
```dart
final firstName = ValueCell.computed(() => person().firstName);
```
</CodeGroup>

If you want the `firstName` cell to be settable, so that setting the
value of `firstName` updates the `person` cell, you'll need to define
a `copyWith` method and a mutable computed cell:


<CodeGroup title="Mutating properties in cells">
```dart
final firstName = MutableCell.computed(() => person().firstName, (name) {
	person.value = person.value.copyWith(
		firstName: name
	);
});
```
</CodeGroup>

This is the definition of boilerplate and will quickly become tiring.

The `live_cell_extension` package automatically generates this code
for you, so that instead of the above, you can write the following:

<CodeGroup title="Generated ValueCell property accessors">
```dart
final firstName = person.firstName;
```
</CodeGroup>

And to update the value of the `firstName` property:

<CodeGroup title="Generated MutableCell property accessors">
```dart
person.firstName = 'Jane';
```
</CodeGroup>

That's it, no need to write a `copyWith` method either. This ties in
with Live Cell's design principle that cells should be
indistinguishable, as much as is possible, from the values they hold.

### Generating the Code

To make this work you'll need to add the `live_cell_extension` package
to the `dev_dependencies` of your `pubspec.yaml`:

```yaml
dev_dependencies:
	live_cell_extension: 0.3.0
	...
```

Then annotate the classes, for which you want accessors to be
generated, with `CellExtension`. If you want mutable cell accessors to
also be generated, add `mutable: true` to the annotation arguments.

<CodeGroup title="person.dart">
```dart
part 'person.g.dart';

@CellExtension(mutable: true)
class Person {
	final String firstName;
	final String lastName;
	final int age;
	
	const Person({
		required this.firstName,
		required this.lastName,
		required this.age
	});
}
```
</CodeGroup>

<Warning>
Don't forget to include the `<filename>.g.dart` file. This is where
the code will be generated.
</Warning>

Next you'll need to run the following command in the root directory of
your project:

```sh
flutter pub run build_runner build
```

This will generate the `.g.dart` files, which contain the generated
class property accessors.

The `ValueCell` accessors are defined in an extension with the name of
the class followed by `CellExtension`. The `MutableCell` accessors are
defined in an extension with the name of the class followed by
`MutableCellExtension`.

## Binding to Properties

Using the generated property accessors, we can define a form for
populating the class properties simply by binding the property cells,
retrieved using the generated accessors, to the appropriate widgets.

<CodeGroup title="Binding directly to properties">
```dart
Widget personForm(MutableCell<Person> person) => Column(
	children: [
		Text('First Name:'),
		CellText(data: person.firstName),
		Text('Last Name:'),
		CellText(data: person.lastName),
		Text('Age:'),
		numberField(person.age)
	]
);
```
</CodeGroup>

We used the `numberField` widget defined earlier, for the `age`
property.

<Info>

The form is not wrapped in a `StaticWidget` since it will only be used
within a static widget.

</Info>

We can then use this form as follows:

```dart
Widget example() => StaticWidget.builder((_) {
	final person = MutableCell(
		Person(
			firstName: 'John',
			lastName: 'Smith',
			age: 25
		)
	);
	
	return Column(
		children: [
			personForm(person),
			CellText(
				data: ValueCell.computed(
					() => '${person.firstName()} ${person.lastName()}: ${person.age()} years'
				)
			),
			ElevatedButton(
				child: Text('Save'),
				// A hypothetical savePerson function
				onPressed: () => savePerson(person.value)
			),
			ElevatedButton(
				child: Text('Reset'),
				onPressed: () => person.value = Person(
					firstName: 'John',
					lastName: 'Smith',
					age: 25
				)
			)	
		]
	);
});
```

In this example we used the `personForm` widget defined earlier. 

* The details of the person are displayed in a `CellText`, which is
  automatically updated when the person's details are changed.
* The "Save" button saves the entered details, which are held in the
  `person` cell.
* The "Reset" button resets the form fields to their defaults by
  directly assigning a default `Person` to the `person` cell.
  
The benefits of this, as opposed to using the tools already available
in Flutter, are:

* No need to write event handlers and state synchronization code for
  acquiring input from the user. This is all handled automatically.
* You can focus directly on the representation of your data and think
  in terms of your data, rather than thinking in terms of widget `State`.
* Your widgets are bound directly to your data and kept in sync. There
  is no chance of you accidentally forgetting to synchronize them with
  your data and vice versa, which eliminates a whole class of bugs.
